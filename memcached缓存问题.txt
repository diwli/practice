1、缓存无底洞
问题分析：
以用户为例：user-133-age,user-133-name,user-133-height....N个Key，
当服务器增多，133号用户的信息，也被散落在更多的节点，
所以，同样是访问个人主页，得到相同的个人信息，节点越多，要连接的节点也越多。
事实上：
nosql 和 传统的rdbms，并不是水火不容的，两者可以相互参考
比如：user表下，有age、name、height列。
对应的key，可以用user:133：age=23，user:133:name="lisi";
解决方案：
将某一组key，按照其共同前缀分布。
比如：user-133-age,user-133-name,user-133-height 这3个key，
在用分布式算法求其节点的时候，应该以“user-133”来计算，而不是以user-133-name/age/height来计算。
这样的，3个关于个人信息的key，都落在同一个节点上，访问个人主页时，只需要连接一个节点
现象：key对应的value值是分散存到不同的memcache里的，查找一个key的键值，要到多台memcached内分别拿数据

解决方案：
key对应的value值不要分散存储到不同的memcached，只存入一个memcache内。

2、缓存雪崩
现象：同一时刻，存进memcache的数据同时过期。
解决方案：
a 给数据缓存设置不同的随机失效时间，不让缓存数据在某个时间点同时失效（随机设计3-9个小时的生命周期）
  把建立缓存的负载分摊到每个时间点上
b 把数据缓存失效时间尽量设置在半夜

3、永久数据被踢现象
操作系统的内存管理，常用FIFO、LRU删除机制
当一个单元被请求时，memcached删除就是lRU删除 最近最少使用的。。新数据就会把这些老数据踢掉

提示：
a 数据在内存中并未真正删除，系统也不知道某个item已经失效，下次get时才知道失效，才把chuck清空
b 如果slab里的很多chunk都已经过期，但从没有被get过，系统不知他们已经过期
c 永久数据很久没get了，不活跃了，如果新增item，则永久数据被踢了
d 当然，如果那些非永久数据被get，也会被标记为expire，从而不会再踢掉永久性数据

解决方法 ： 永久数据与非永久数据 分开放

